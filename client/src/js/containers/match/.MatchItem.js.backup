import React, { Component } from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import * as matchAction from '../../modules/match';
import * as userAction from '../../modules/user';

class ConnectedMatchItem extends Component {
	constructor() {
		super();
		this.state = {
			isLoading: false,
			_id: null,
			option: null,
			result: null,
			betMoney: 0,
			isBet: false,
			dividendRate: [],
			isAdmin: false
		};
	}

	componentWillMount() {
		const { _id } = this.props.match;
		this.setState({
			_id
		});
	}

	componentDidMount() {
		const { MatchAction, match, userEmail } = this.props;
		const { _id } = this.state;
		const { bettingState, bettingUsers, bettingOptions, result } = match;
		const bettingUserIndex = bettingUsers.findIndex(info => info.userEmail === userEmail);
		const newDate = new Date(match.date).getTime();
		const curDate = new Date().getTime();

		let dividendRate = new Array(bettingOptions.length).fill(0);
		for (let i = 0; i < bettingUsers.length; i += 1) {
			dividendRate[bettingUsers[i].option] += bettingUsers[i].betMoney;
		}
		const sum = dividendRate.reduce((a, i) => a + i, 0);
		dividendRate = dividendRate.map((d, i) => {
			if (d === 0) {
				return 0;
			}
			return d / sum.toFixed(2);
		});

		this.setState({ dividendRate, isAdmin: userEmail === 'nohtaesang@naver.com' });

		if (bettingUserIndex === -1) {
			this.setState({
				isBet: false,
				betMoney: 0
			});
		} else {
			this.setState({
				isBet: true,
				betMoney: bettingUsers[bettingUserIndex].betMoney,
				option: bettingUsers[bettingUserIndex].option
			});
		}

		// 0: 경기전 1: 경기중 2: 경기 종료
		if (bettingState === 0 && curDate >= newDate) {
			MatchAction.setBettingState(_id, 1);
		} else if (bettingState === 2) {
			this.setState({
				result
			});
		}
	}

	clickDeleteMatch = async () => {
		const { _id } = this.state;
		const { MatchAction, numberOfMatches, matchOption } = this.props;
		try {
			await MatchAction.deleteMatch(_id);
			await this.getMatchList(numberOfMatches, matchOption);
		} catch (e) {
			console.log('err');
		}
	};

	getMatchList = async () => {
		const { MatchAction, numberOfMatches, matchOption } = this.props;
		try {
			await MatchAction.getMatchList(numberOfMatches, matchOption);
		} catch (e) {
			console.log('err');
		}
	};

	clickBettingOption = async e => {
		const { option } = this.state;
		let newOption = parseInt(e.target.name, 10);

		if (option === newOption) {
			newOption = null;
		}

		this.setState({
			option: newOption
		});
	};

	changeBetMoney = async e => {
		const { userMoney } = this.props;
		let betMoney = parseInt(e.target.value, 10);
		if (betMoney < 0) {
			betMoney = 0;
		} else if (betMoney > parseInt(userMoney, 10)) {
			betMoney = parseInt(userMoney, 10);
		}

		this.setState({
			betMoney
		});
	};

	clickBet = async e => {
		const { MatchAction, UserAction, userEmail, userMoney, match } = this.props;
		const { isLoading, _id, option, betMoney } = this.state;

		const newDate = new Date(match.date).getTime();
		const curDate = new Date().getTime();
		if (isLoading || option === null || betMoney <= 0 || userEmail === null || curDate >= newDate) return;

		try {
			this.setState({ isLoading: true });
			await MatchAction.bet(_id, userEmail, option, betMoney);
			await UserAction.setUserMoney(userEmail, userMoney - betMoney);
			this.setState({
				isLoading: false,
				isBet: true
			});
		} catch (err) {
			console.log(err);
		}
	};

	clickCancelBet = async e => {
		const { MatchAction, UserAction, userEmail, userMoney, match } = this.props;
		const { isLoading, _id, betMoney, isAdmin } = this.state;

		if (isLoading) return;
		try {
			this.setState({ isLoading: true });
			await MatchAction.cancelBet(_id, userEmail);
			await UserAction.setUserMoney(userEmail, userMoney + betMoney);
			this.setState({ isLoading: false, isBet: false });
		} catch (err) {
			console.log(err);
		}
	};

	updateMatch = async (id, update, index) => {
		const { MatchAction } = this.props;
		try {
			await MatchAction.updateMatch(id, update);
			await this.getMatchList(this.props.numberOfMatches, this.props.matchOption);
		} catch (err) {
			console.log(err);
		}
	};

	clickBettingState = async (state) => {
		const { _id } = this.state;
		const { MatchAction } = this.props;
		MatchAction.setBettingState(_id, state);
	};

	setBettingResult = async () => {
		const { _id, result } = this.state;
		const { MatchAction } = this.props;
		if (result === null) return;
		MatchAction.setBettingResult(_id, result);
	}

	clickBettingResult = async (e) => {
		const result = parseInt(e.target.name, 10);
		this.setState({ result });
	}

	render() {
		const { option, betMoney, isBet, dividendRate, isAdmin, _id, result } = this.state;
		const { match, home, away } = this.props;
		const { bettingOptions, bettingState, category, date, bettingUsers } = match;
		const newDate = new Date(date);
		// console.log(result);
		return (
			<div className={!isBet ? 'matchItem' : 'matchItem bet'}>
				<div className="info">
					<div className="date">
						{`${newDate.getFullYear()}/${newDate.getMonth()
							+ 1}/${newDate.getDate()} ${newDate.getHours()}:00시 마감`}
					</div>
					<div className="team">
						{home ? <img className="homeLogo" alt="" src={home.logo} /> : null}
						{away ? <img className="awayLogo" alt="" src={away.logo} /> : null}
					</div>
				</div>
				{!isBet && bettingState === 0 ? (
					<div className="options">
						{bettingOptions.map((o, i) => (
							<button
								type="button"
								key={i}
								name={i}
								className={i === option && i === result ? 'pick result' : i === option ? 'pick' : i === result ? 'result' : null}
								onClick={this.clickBettingOption}
							>
								{`${o.homeScore} : ${o.awayScore} (x${dividendRate[i]}배)`}
							</button>
						))}
					</div>
				) : (
					<div className="options">
						{bettingOptions.map((o, i) => (
							<button
								type="button"
								key={i}
								name={i}
								className={i === option ? 'pick' : null}
								onClick={this.clickBettingOption}
								disabled
							>
								{`${o.homeScore} : ${o.awayScore} (x${dividendRate[i]}배)`}
							</button>
						))}
					</div>
				)}
				{bettingState === 0 ? (
					!isBet ? (
						<div className="beforeBet">
							<input type="number" className="betMoney" value={betMoney} onChange={this.changeBetMoney} />
							<button type="button" className="betBtn" onClick={this.clickBet}>
								{`${betMoney}원 배팅하기`}
							</button>
						</div>
					) : (
						<button type="button" className="betCancelBtn" onClick={this.clickCancelBet}>
							{'취소하기'}
						</button>
					)
				) : null}
				{isAdmin ? (
					<div className="admin">
						{bettingState === 0 ? <button type="button" onClick={() => this.clickBettingState(1)}>배팅마감</button> : null}
						{bettingState === 1 ? (
							<div>
								<div className="options">
									{bettingOptions.map((o, i) => (
										<button
											type="button"
											key={i}
											name={i}
											className={i === result ? 'result' : null}
											onClick={this.clickBettingResult}
										>
											{`${o.homeScore} : ${o.awayScore} (x${dividendRate[i]}배)`}
										</button>
									))}
								</div>
								<button type="button" onClick={() => this.setBettingResult()}>경기종료</button>
							</div>
						) : null}
						<button type="button" onClick={this.clickDeleteMatch}>삭제하기</button>
					</div>
				) : null}
			</div>
		);
	}
}

export default connect(
	state => ({
		matchList: state.match.matchList,
		numberOfMatches: state.match.numberOfMatches,
		matchOption: state.match.matchOption,
		userEmail: state.user.userEmail,
		userMoney: state.user.userMoney
	}),
	dispatch => ({
		MatchAction: bindActionCreators(matchAction, dispatch),
		UserAction: bindActionCreators(userAction, dispatch)
	})
)(ConnectedMatchItem);
